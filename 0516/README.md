# 5월 16일 수업내용

---

# 7장 파일 및 레코드 잠금

## 7.1 파일 잠금

- **파일 잠금의 목적**: 여러 프로세스가 동시에 파일을 수정하거나 읽는 것을 제어하여 데이터 불일치 방지
- **문제 사례**: 두 프로세스가 동시에 계좌 파일을 수정하면 잔액 오류 발생 가능
- **파일 잠금의 방식**: 전체 파일을 대상으로 한 공유 잠금(LOCK_SH)과 배타 잠금(LOCK_EX)이 존재
- **잠금 해제**: LOCK_UN 사용
- **비동기 잠금**: LOCK_NB 옵션을 통해 잠금 실패 시 즉시 반환
- **파일 잠금 상태와 요청 간의 관계**:
  - 잠금 없음 → 공유/배타 모두 가능
  - 공유 잠금 존재 시 → 추가 공유는 가능, 배타는 거절
  - 배타 잠금 존재 시 → 모든 요청 거절

## 7.2 레코드 잠금

- **레코드 잠금이란**: 파일의 일부 영역(특정 레코드)을 잠금하여 보다 세밀한 동시성 제어 가능
- **파일 전체 잠금과의 차이**: 파일 잠금은 전체 파일에 영향, 레코드 잠금은 특정 바이트 범위만 제한
- **잠금 유형**:
  - `F_RDLCK`: 읽기 잠금 (공유 가능)
  - `F_WRLCK`: 쓰기 잠금 (단독 접근)
  - `F_UNLCK`: 잠금 해제
- **잠금 제어 함수**: fcntl() 호출로 잠금 상태 조회, 설정, 해제 가능
- **레코드의 위치와 길이를 지정하여 잠금 적용**
- **사용 사례**: 특정 학생 정보를 동시에 수정/조회하는 경우 충돌 방지

## 7.3 잠금 함수

- **lockf() 함수**: POSIX 기반의 간단한 잠금 함수
- **주요 명령어**:
  - `F_LOCK`: 쓰기 잠금 설정, 잠금 해제까지 대기
  - `F_TLOCK`: 쓰기 잠금 설정, 실패 시 즉시 반환
  - `F_TEST`: 잠금 상태 확인
  - `F_ULOCK`: 잠금 해제
- **적용 범위**: 현재 파일 위치부터 지정한 바이트 수만큼

## 7.4 권고 잠금과 강제 잠금

- **권고 잠금 (Advisory Locking)**:
  - 잠금 상태는 단순 정보이며, 다른 프로세스가 무시하고 접근 가능
  - 모든 관련 프로세스가 잠금 규칙을 자발적으로 따라야 효과 있음
  - 리눅스, BSD, macOS에서 기본 제공

- **강제 잠금 (Mandatory Locking)**:
  - 커널이 잠금 규칙을 강제하며, 잠긴 파일에 접근을 차단
  - 관련 시스템은 System V, Solaris 등
  - 리눅스에서는 `-o mand` 마운트 옵션과 파일 권한 설정을 통해 가능
  - 적용 방법:
    - set-group-ID 비트 설정
    - group-execute 비트 제거

## 핵심 개념 정리

- 하나의 파일 또는 레코드를 여러 프로세스가 동시에 다룰 때 충돌 방지를 위해 잠금이 필요하다.
- `flock()`: 파일 전체 잠금
- `fcntl()`: 레코드 단위의 세밀한 잠금 제어
- `lockf()`: POSIX 계열에서 제공하는 간단한 잠금 함수
- 권고 잠금은 강제력이 없지만, 강제 잠금은 운영체제가 보호해준다.

---

# 8장 파일 유틸리티

## 8.1 파일 속성으로 파일 찾기

- `find` 명령어를 사용하여 파일 이름, 소유자, 크기, 타입, 권한, 접근/수정 시간 등을 기준으로 검색할 수 있음.
- 주요 옵션:
  - `-name`: 파일 이름
  - `-user`: 소유자
  - `-size`: 크기
  - `-type`: 파일 종류 (d, f, l, b, c, s 등)
  - `-perm`: 권한
  - `-atime`, `-mtime`: 접근 또는 수정 시간
- 여러 옵션을 조합하여 복합 조건으로 검색 가능
- `-exec` 옵션을 활용하면 검색된 각 파일에 대해 명령어 수행 가능 (예: 삭제, 출력 등)

## 8.2 파일 필터링

- `grep` 명령어로 텍스트 파일에서 지정된 문자열 패턴을 포함한 줄만 출력
- 주요 옵션:
  - `-i`: 대소문자 무시
  - `-l`: 해당 패턴을 포함하는 파일 이름 출력
  - `-n`: 줄 번호 출력
  - `-v`: 패턴 미포함 줄 출력
  - `-c`: 일치하는 줄 수 출력
  - `-w`: 정확히 일치하는 단어만 검색
- 정규표현식을 이용하여 유연한 패턴 검색 가능
  - `.`: 임의의 한 문자
  - `*`: 앞 문자의 반복
  - `[abc]`: a, b, c 중 하나
  - `[^abc]`: a, b, c를 제외한 문자
  - `^`, `$`: 줄의 시작과 끝
- 파이프(`|`)와 함께 사용하여 다른 명령어 출력 결과를 필터링 가능

## 8.3 파일 정렬

- `sort` 명령어로 텍스트 파일의 줄들을 정렬
- 기본은 첫 필드를 기준으로 오름차순 정렬
- 주요 옵션:
  - `-r`: 내림차순
  - `-n`: 숫자 값 기준 정렬
  - `-k`: 특정 필드를 기준으로 정렬
  - `-t`: 구분자 지정
  - `-o`: 정렬 결과를 지정한 파일에 저장
- `+s -e` 문법으로 특정 필드 범위 기준 정렬 가능 (구형 문법)
- `-b`, `-c`, `-d`, `-f` 등 다양한 옵션으로 공백 무시, 정렬 여부 확인, 사전식 정렬 등 가능

## 8.4 파일 비교

- `cmp` 명령어는 두 파일의 내용이 같은지 바이트 단위로 비교
  - 같으면 출력 없음, 다르면 다른 위치 출력
- `diff` 명령어는 줄 단위 차이를 비교하고 편집 명령어 형태로 출력
  - `a`: 삽입
  - `d`: 삭제
  - `c`: 변경
- `-i` 옵션으로 대소문자 무시 가능

## 8.5 기타 파일 조작

- `split`: 하나의 파일을 지정된 줄 수 단위로 여러 파일로 분할
- `cat`: 여러 파일을 이어 붙여 출력 또는 새로운 파일로 저장
- `paste`: 여러 파일을 줄 단위로 병합
  - `-s` 옵션으로 한 파일 끝에 다른 파일 내용을 덧붙이는 방식
  - `-d`: 구분 문자 지정 가능

## 핵심 개념 정리

- `find`: 다양한 속성 기준으로 파일 검색
- `grep`: 문자열 패턴으로 텍스트 필터링
- `sort`: 텍스트 파일 정렬
- `cmp`: 파일 내용 일치 여부 비교 (바이트 단위)
- `diff`: 줄 단위 비교 및 수정 차이 확인
- `split`, `cat`, `paste`: 파일의 분할 및 병합 도구
