# 5월 23일 수업내용

## 9.1 프로세스 생성

- **fork()** 시스템 호출을 통해 부모 프로세스가 자신과 동일한 자식 프로세스를 생성함 (자기 복제)
- **fork()의 리턴값**:
  - 자식에게는 0, 부모에게는 자식의 PID를 반환
- **병행 실행**: 부모와 자식은 fork 이후 각각 독립적으로 실행을 계속함
- **리턴값으로 프로세스 구분 가능**: 리턴값을 기반으로 부모/자식 구분 후 서로 다른 코드 실행 가능
- **복수 자식 생성 가능**: fork 여러 번 호출하여 자식 프로세스 여러 개 생성 가능

## 9.1-2 프로세스 기다리기

- **wait() 함수**: 자식 프로세스가 종료될 때까지 부모가 대기
  - 종료된 자식의 PID와 종료 상태를 반환
- **waitpid() 함수**: 특정 자식 프로세스가 종료될 때까지 대기 가능
  - 다양한 옵션 사용 가능 (예: WNOHANG)
- **상태 값 처리**: `status >> 8` 또는 매크로로 종료 코드 추출

## 9.2 프로그램 실행

- **exec() 계열 함수**: 현재 프로세스 내의 코드를 새로운 프로그램으로 완전히 대체
  - 자기대치(self-replacement), main()부터 새 프로그램이 실행됨
- **종류**:
  - `execl`, `execv`: 경로 직접 지정
  - `execlp`, `execvp`: PATH 환경변수 기반으로 파일 탐색
- **fork + exec 조합**: 자식 프로세스를 생성한 후 exec()로 새 프로그램 실행 → 부모는 기존 코드 계속 실행
- **system() 함수**: 내부적으로 fork, exec, wait를 사용하여 명령어 실행
  - `/bin/sh -c`를 통해 명령어 수행
  - 종료 코드 반환

## 9.3 입출력 재지정

- **표준 출력 재지정**: 명령어의 출력이 화면 대신 파일에 저장되도록 함
  - 쉘 문법: `명령어 > 파일`
  - C에서 구현 시 `dup2()` 사용: 파일 디스크립터를 표준 출력(1)에 복제
- **입출력 제어 흐름**:
  1. 파일 열기 → `open()`
  2. `dup2(fd, 1)` → 표준출력 대체
  3. 기존 `fd` 닫기 → `close()`
  4. 명령 실행 → `execvp()` 등

## 9.4 프로세스 그룹

- **정의**: 여러 프로세스의 논리적 집합. 기본적으로 부모-자식 간은 동일한 프로세스 그룹에 속함
- **용도**:
  - 전체 그룹에 시그널 전송
  - 그룹 기반 wait 가능
- **프로세스 그룹 ID (PGID)**:
  - `getpgrp()`: 현재 프로세스의 그룹 ID 반환
  - `setpgid(pid, pgid)`: 특정 프로세스의 그룹 ID를 설정
    - `setpgid(0, 0)`은 자신을 새 그룹 리더로 지정
- **시그널 전송 예**:
  - `kill -9 PID`: 개별 프로세스
  - `kill -9 0`: 현재 쉘의 프로세스 그룹
  - `kill -9 -PGID`: 지정 그룹 전체

## 9.5 시스템 부팅

- **fork/exec 체계로 구성**:
  - 커널 → `swapper` → `init` → `getty` → `login` → `shell` 순으로 진행
- **주요 프로세스**:
  - `swapper`: 최초 커널 스케줄러
  - `init`: 시스템 초기화 담당
  - `getty`: 로그인 대기 및 사용자 입력 감지
  - `login`: 사용자 인증
  - `shell`: 사용자 명령어 처리

## 핵심 개념 요약

- **프로세스**: 실행 중인 프로그램
- **fork()**: 부모 프로세스 복제 → 자식 생성
- **exec()**: 기존 프로그램을 새로운 프로그램으로 대치
- **wait/waitpid**: 자식 종료를 기다림
- **dup/dup2**: 입출력 파일 디스크립터 복제 및 재지정
- **프로세스 그룹**: 관련된 프로세스를 그룹으로 묶어 관리
- **시스템 부팅**: fork/exec 호출의 연속적인 체계로 프로세스를 계층적으로 구성
